spring.application.name=sensor-ingestion-service
spring.main.web-application-type=servlet
server.port=8080

management.endpoints.web.exposure.include=health,info
management.endpoint.health.probes.enabled=true
management.health.livenessstate.enabled=true
management.health.readinessstate.enabled=true

# Kafka
spring.kafka.bootstrap-servers=${KAFKA_BOOTSTRAP:kafka:9092}
spring.kafka.consumer.group-id=iot-ingestion
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.max-poll-records=500

# Listener: BATCH + MANUAL ack (matches your method signature)
spring.kafka.listener.type=batch
spring.kafka.listener.ack-mode=manual
spring.kafka.listener.poll-timeout=3000

# Consumer deserializers: keep VALUE as STRING
spring.kafka.consumer.key-deserializer=org.springframework.kafka.support.serializer.ErrorHandlingDeserializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.ErrorHandlingDeserializer
spring.kafka.consumer.properties.spring.deserializer.key.delegate.class=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.properties.spring.deserializer.value.delegate.class=org.apache.kafka.common.serialization.StringDeserializer

# Producer serializer (for retry/DLT publish via @RetryableTopic)
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer

# App config
app.topic=iot.readings.raw

# Postgres
spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST:iot-postgres}:${POSTGRES_PORT:5432}/${POSTGRES_DB:iotdb}
spring.datasource.username=${POSTGRES_USER:postgres}
spring.datasource.password=${POSTGRES_PASSWORD:postgres}
spring.datasource.hikari.maximum-pool-size=10

# Flyway
spring.flyway.enabled=true
spring.flyway.schemas=iot
spring.flyway.validate-on-migrate=true
spring.flyway.clean-disabled=true

# Logging
logging.level.org.springframework.kafka=DEBUG
logging.level.org.apache.kafka.clients.consumer=INFO
